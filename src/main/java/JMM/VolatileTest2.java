package JMM;

/**
 * @author AOBO
 * @date 2021-11-24 00:04
 * @description Volatile保证有序性
 */

/**
 * JVM会在不影响正确性的前提性下  调整语句的执行顺序
 * 这种调整在单线程下无影响  但多线程下  会影响程序正确性
 *
 * CPU要有指令重排优化的原因：   减少流水线阻塞
 * 每一条指令都可以分为五个阶段： 取指令 指令译码 执行指令 内存访问 数据写回
 * 在不改变程序结果的前提下 这些指令的各个阶段可以通过重排序和组合来实现指令级并行
 * 否则一条一条执行肯定费时间(将各个指令像流水线一样排布  节约时间)
 * 现代CPU支持多级指令流水线  在一个时钟周期内 同时运行五条指令的不同阶段
 * 所以流水线技术并不能缩短单条指令的执行时间 但能够提高指令的吞吐量
 *
 * JAVA层面 JIT即时编译器在运行时候  也会有指令重排
 *
 * volatile 可以禁止指令重排序 保证顺序性
 * 但保证的只是本线程内的代码不被重排序
 */

/**
 * volatile的底层实现原理是内存屏障 Memory Barrier
 * 对volatile变量的写指令后会加入写屏障
 * 对volatile变量的读指令前会加入读屏障
 *
 * 对可见性的保证：
 * 写屏障保证该屏障之前 对共享变量的改动都同步到主存当中
 * 也就是对该变量的写操作之后(包含写操作之前的操作 如之前非volatile变量的修改) 都会同步到主存中
 *
 * 读屏障保证该屏障之后 对共享变量的读取都加载的是主存中的最新数据
 * 也就是对该变量的读操作之前 会从主存中加载最新数据到工作内存(缓存)
 *
 * 对有序性的保证：
 * 写屏障会确保指令重排序时 不会将写屏障之前的代码排在写屏障之后
 * 也就是写入的时候  前面的代码肯定都执行完了
 * 因为写操作之后  要将之前的所有改动都同步到主存中去 所以之前的代码肯定都要执行完
 *
 * 读屏障会确保指令重排序时 不会将读屏障之后的代码排在读屏障之前
 * 也就是读取的时候  后面的代码肯定都还没执行
 * 因为读操作之前  要去主存中取最新的变量值  所以之后的代码都不能执行
 *
 *
 * 所以加了volatile关键字的变量：
 * 写操作之前的代码可肯定都执行完了  并且写之后将所有改动都同步到主存中去
 * 读操作之前从主存中读取最新的变量  并且读之后的所有代码 都还没有执行
 */

//双重检查DCL(Double Checked Locking)加volatile保证线程安全的懒汉式
public class VolatileTest2 {
    //这里volatile的是必须加的  这里的volatile主要保证的是顺序性
    private static volatile VolatileTest2 INSTANCE;

    private VolatileTest2(){

    }

    //为什么单例要用静态方法get  而不是直接public final来get静态成员变量
    //是为了提供更好的封装性  可以实现懒加载  还可以对创建时有更多的控制 可以提供泛型的支持
    public static VolatileTest2 getInstance(){
        if (INSTANCE == null){
            //synchronized 虽然可以保证顺序性(synchronized原子性 可见性 顺序行都保证)
            //但synchronized的顺序性  是整个代码块内和代码块外的顺序性
            //但synchronized内部代码还是可以发生指令重排的
            synchronized (VolatileTest2.class){
                if (INSTANCE == null){
                    //这里的操作不是原子的  new的时候主要有三个步骤
                    //1.申请内存空间
                    //2.调用构造器
                    //3.将INSTANCE的引用 指向堆中分配的内存的空间 完成赋值操作

                    //这时如果没有volatile就有可能发生指令重排  比如将第三步和第二步调换了位置
                    //就有可能导致INSTANCE已经指向内存中的一个地址了  但实际上还没有调用构造器
                    //如果这时CPU发生上下文切换  另一个线程执行到了最外层的if判断
                    //就会直接返回一个还没有初始化的INSTANCE 产生错误

                    //而加了volatile之后  会在写操作的下面加一个写屏障
                    //也就是在第三步的将INSTANCE引用指向堆中分配的内存空间后面 加写屏障
                    //写屏障保证了写屏障之前的指令 不会排到写屏障之后
                    //也就保证了第二步不会在第三步之后  第三步永远是最后一步操作
                    //这样即使在第二步和第三步之间切换走  外层的if判断 还是正确的
                    INSTANCE = new VolatileTest2();
                }
            }
        }
        return INSTANCE;
    }
}


/**
 * happens-before原则
 * 规定了以下几种情况   对共享变量都的写操作对其他线程的读操作可见
 *
 * 1.线程解锁之前对变量的写 对之后加锁的其他线程对该变量的读取是可见的
 * (其实就是synchronized在加锁前会清空工作内存  重新读取主存  在解锁时会将工作内存写入主存)
 *
 * 2.volatile变量的写 对接下来其他线程对该线程的读是可见的
 *
 * 3.线程start前对变量的写  对该线程开始后的该变量的读可见(线程开始后 从主存读新数据到工作内存)
 *
 * 4.线程结束前对变量的写   对其他线程得知它结束之后的读可见
 * (比如调用isAlive()或join()等待结束 线程结束会将工作内存同步到主存)
 *
 * 5.线程t1打断t2前对变量的写  对其他线程得知t2被打断后  对变量的读可见(检测isInterrupted之后 读可见)
 *
 * 6.对变量默认值的改变(零假空)  对其他线程可见  会通知其他线程
 *
 * 7.volatile写操作之前的其他变量的改变 也会被读取volatile变量的其他线程可见
 * (volatile写操作后 写入主存 是将volatile写操作已经之前的所有操作 都写入主存)
 */